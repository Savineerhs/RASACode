import { LineCounter } from 'yaml'; 
import { RASADeclarationType, TrainingData, Domain } from './definitions';
import { readFileSync } from 'fs';

const YAML = require('yaml');

export function readAll(ymlPaths: string[], domain: Domain, trainingData: TrainingData)
{
    ymlPaths.forEach(function(path) 
	{
		readYML(path, domain, trainingData);
	});
}


export function readYML(path: string, domain: Domain, trainingData: TrainingData)
{
    let counter = new LineCounter();		
    const ymlContent = 
        YAML.parseDocument(
            readFileSync(path, 'utf-8'),
            { keepCstNodes: true, 
            lineCounter: counter}
        )["contents"]
    
    if (ymlContent)
    {
        const declarationBlocksInDocument = Object.values(ymlContent["items"]);
        declarationBlocksInDocument.forEach(function(declarationBlock: any) 
        {
            const declarationBlockName = declarationBlock["key"].toString(); 
            
            switch (declarationBlockName)
            {
                // == Training declarations ==
                case "stories":
                    let storyDeclarations = getStoryDeclarations(declarationBlock, counter, path); 
                    storyDeclarations.forEach(declaration => {trainingData.addContribution(path, declaration)});
                    break; 
                    
                case "rules":
                    let ruleDeclarations = getRuleDeclarations(declarationBlock, counter, path); 
                    ruleDeclarations.forEach(declaration => {trainingData.addContribution(path, declaration)});
                    break; 

                case "nlu":
                    let nluDeclarations = getNluDeclarations(declarationBlock, counter, path); 
                    nluDeclarations.forEach(declaration => {trainingData.addContribution(path, declaration)});
                    break; 
                    
                // == Domain declarations == 
                case "intents": 
                    let declaredIntents = getIntentDeclarations(declarationBlock, counter, path);  
                    declaredIntents.forEach(intent => {domain.addContribution(path, intent)});
                    break;


                case "actions": 
                    let declaredActions = getActionDeclarations(declarationBlock, counter, path); 
                    declaredActions.forEach(action => {domain.addContribution(path, action)});
                    break; 


                case "responses": 
                    let declaredResponses = getResponseDeclarations(declarationBlock, counter, path); 
                    declaredResponses.forEach(response => {domain.addContribution(path, response)});
                    break; 

                default: 
                    break; 
            }
        })
    }
}


function getStoryDeclarations(data: any, counter: LineCounter, filePath: string) 
{
    // This file declares stories
    let declarationsInThisFile: any[] = [];
    const storyBlocksInThisFile = data["value"]["items"]
    storyBlocksInThisFile.forEach(function (storyBlock: any) {
        // Most of this stuff is just navigating the CST tree generated by the YAML parser. 
        // Hopefully the variable names make it a bit clearer what's doing what.  
        let storyBlockKey = storyBlock["items"][0]["value"]
        let storyPosition = getUsablePosition(storyBlockKey["range"]["0"], counter)
        let storyDeclaration = {
            "file": filePath,
            "position": storyPosition,
            "type": RASADeclarationType.StoryLocation,
            "length": storyBlockKey["range"][1] - storyBlockKey["range"][0],
            "declaration": storyBlock["items"][0]["value"].toString()
        };

        declarationsInThisFile.push(storyDeclaration);
        
        let stepsInThisBlock = storyBlock["items"][1]["value"]["items"]

        stepsInThisBlock.forEach(function (step: any) 
        {
            let stepType = step["items"][0]["key"].toString();
            let stepDeclarationUsed = step["items"][0]["value"].toString();
            let stepStartOffset = step["range"][0];
            let position = getUsablePosition(stepStartOffset, counter);

            if (stepType === "intent") {
                
                let o = {
                    "file": filePath,
                    "position": position,
                    "type": RASADeclarationType.IntentInStory,
                    "length": step["range"][1] - step["range"][0],
                    "declaration": stepDeclarationUsed
                };

                declarationsInThisFile.push(o);
            }

            if (stepType === "action") {
                let o = {
                    "file": filePath,
                    "position": position,
                    "type": RASADeclarationType.ActionInStory,
                    "length": step["range"][1] - step["range"][0],
                    "declaration": stepDeclarationUsed
                };

                declarationsInThisFile.push(o);
            }
        });
    }); 

    return declarationsInThisFile;
}


function getRuleDeclarations(data: any, counter: LineCounter, filePath: string) 
{
    // This file declares stories
    let declarationsInThisFile: any[] = [] 
    const ruleBlocksInThisFile = data["value"]["items"]
    ruleBlocksInThisFile.forEach(function (ruleBlock: any) {
        // Most of this stuff is just navigating the CST tree generated by the YAML parser. 
        // Hopefully the variable names make it a bit clearer what's doing what.  
        let ruleBlockKey = ruleBlock["items"][0]["value"]
        let rulePosition = getUsablePosition(ruleBlockKey["range"]["0"], counter)
        let ruleDeclaration = {
            "file": filePath,
            "position": rulePosition,
            "type": RASADeclarationType.RuleLocation,
            "length": ruleBlockKey["range"][1] - ruleBlockKey["range"][0],
            "declaration": ruleBlock["items"][0]["value"].toString()
        };
        
        declarationsInThisFile.push(ruleDeclaration);
        
        let stepsInThisBlock = ruleBlock["items"][1]["value"]["items"]

        stepsInThisBlock.forEach(function (step: any) 
        {
            let stepType = step["items"][0]["key"].toString();
            let stepDeclarationUsed = step["items"][0]["value"].toString();
            let stepStartOffset = step["range"][0];
            let position = getUsablePosition(stepStartOffset, counter);

            if (stepType === "intent") {
                
                let o = {
                    "file": filePath,
                    "position": position,
                    "type": RASADeclarationType.IntentInRule,
                    "length": step["range"][1] - step["range"][0],
                    "declaration": stepDeclarationUsed
                };

                declarationsInThisFile.push(o);
            }

            if (stepType === "action") {
                let o = {
                    "file": filePath,
                    "position": position,
                    "type": RASADeclarationType.ActionInRule,
                    "length": step["range"][1] - step["range"][0],
                    "declaration": stepDeclarationUsed
                };

                declarationsInThisFile.push(o);
            }
        });
    }); 

    return declarationsInThisFile;
}


function getNluDeclarations(data: any, counter: LineCounter, filePath: string)
{
    let declarationsInThisFile: any[] = []
        
    const nluBlocksInThisFile = data["value"]["items"];
    nluBlocksInThisFile.forEach(function (nluBlock: any) 
    {
        let intentName = nluBlock["items"][0]["value"].toString();
        let stepStartOffset = nluBlock["range"][0];
        let position = getUsablePosition(stepStartOffset, counter);

        let o = {
            "file": filePath,
            "position": position,
            "type": RASADeclarationType.IntentInNLU,
            "length": nluBlock["range"][1] - nluBlock["range"][0],
            "declaration": intentName
        };
        
        declarationsInThisFile.push(o);
    });

    return declarationsInThisFile;
}


function getIntentDeclarations(data: any, counter: LineCounter, filePath: string) 
{
    // This file declares nlu in domain
    let declarationsInThisFile: any[] = []; 
    const intentsDeclaredInFile = data["value"]["items"];
    
    intentsDeclaredInFile.forEach(function(intent: any) 
    {
        const position = getUsablePosition(intent["range"][0], counter);

        let o = {
            "file": filePath,
            "position": position,
            "type": RASADeclarationType.IntentDeclaration,
            "length": intent["range"][1] - intent["range"][0],
            "declaration": intent["value"].toString()
        };

        declarationsInThisFile.push(o);
    });
    
    return declarationsInThisFile;
}


function getActionDeclarations(data: any, counter: LineCounter, filePath: string) 
{
    // This file declares actions in domain
    let declarationsInThisFile: any[] = []; 
    const actionsDeclaredInFile = data["value"]["items"];
    
    actionsDeclaredInFile.forEach(function(action: any) 
    {
        const position = getUsablePosition(action["range"][0], counter);

        let o = {
            "file": filePath,
            "position": position,
            "type": RASADeclarationType.ActionDeclaration,
            "length": action["range"][1] - action["range"][0],
            "declaration": action["value"].toString()
        }
        declarationsInThisFile.push(o);
    });
    
    return declarationsInThisFile;
}


function getResponseDeclarations(data: any, counter: LineCounter, filePath: string) 
{
    // This file declares responses into domain
    let declarationsInThisFile: any[] = []; 
    const responsesDeclaredInFile = data["value"]["items"];

    responsesDeclaredInFile.forEach(function(response: any) 
    {
        let responseName: string = response["key"].toString();
        const position = getUsablePosition(response["key"]["range"][0], counter);

        let o = {
            "file": filePath,
            "position": position,
            "type": RASADeclarationType.ResponseDeclaration,
            "length": response["key"]["range"][1] - response["key"]["range"][0],
            "declaration": responseName
        }
        declarationsInThisFile.push(o);
    });


    return declarationsInThisFile;
}


function getUsablePosition(stepStartOffset: number, counter: LineCounter)
{
    let position = counter.linePos(stepStartOffset); 
    // YAML indices are 1-position, while VSCode needs 0-position indices for diagnostics
    position["col"]--; 
    position["line"]--;

    return position
}

export function getKeysInDocument(path: string)
{
    const ymlContent = 
			YAML.parseDocument(
				readFileSync(path, 'utf-8'),
				{ keepCstNodes: true}
			)["contents"]
		
    if (ymlContent)
        return Object.values(ymlContent["items"]).map(function(item: any) {return item["key"].toString()});
    

    return []; 

}

